<div class="slide"><!--<h4 class="title">Modułowe aplikacje WWW</h4>-->
  <div class="slidecontent">
    <% ["M", "O", "D", "U", "Ł", "O", "W", "E", " ", "A", "P", "L", "I", "K", "A", "C", "J", "E", " ", "W", "W", "W", " ", " ", " ", " ", " ", " "].each do |c| %>
      <div class="rect" style="background-color: <%= sprintf("#%.6x;", rand(0xffffff)) %>"><%= c %></div>
    <% end %>
  </div>
</div>

<div class="slide"><h4>Co składa się na aplikację WWW?</h4>
  <div class="slidecontent">
    <ul>
      <li>Obsługa różnych typów szablonów</li>
      <li>Biblioteka metod pomocniczych</li>
      <li>Moduł obsługi błędów</li>
      <li>...</li>
      <li>Wbudowana obsługa baz danych</li>
      <li>Obsługa pamięci podręcznej HTTP (etag, last-modified)</li>
      <li>Moduł i10n</li>
      <li>...</li>
      <li>...</li>
    </ul>
  </div>
</div>

<div class="slide"><h4>Co składa się na aplikację WWW?</h4>
  <div class="slidecontent">
    <p><a href="http://chneukirchen.org/blog/">Christian Neukirchen</a>, 
       <i>Rack: a Ruby Webserver Interface</i></p>

    <blockquote>
      <p>Dabbling in my own web framework experiments, I noticed that
      there is a lot of code duplication among frameworks since they
      essentially all do the same things. And still, every Ruby web
      framework developer is writing his own handlers for every
      webserver he wants to use. Hopefully, the framework users are
      satisfied with that choice.</p>
    </blockquote>

    <p class="def">
      Informally, a <b>Rack application</b>
      is <i><b>a thing</b></i> that responds to <b>#call</b>
      and <b>takes a hash as argument<b>, 
      returning an array of 
      <b>status</b>, <b>headers</b> and a <b>body</b>.
    </p>

    <p>Artykuł Christiana Neukirchena z opisem implementacji powyższej specyfikacji:  
       <i><a href="/doc/neukirchen07introducingrack.pdf">Introducing Rack</a></i>.</p> 
  </div>
</div>

<div class="slide"><h4>Funkcja aplikacją Rack</h4>
<div class="slidecontent">

<pre><code>:::ruby
# app.rb
require 'rubygems'
require 'rack'

App = lambda do |env|
  [
   200,                                             # status
   {"Content-Type" => "text/html; charset=utf-8"},  # headers
   [ "hello world" ]                                # body
  ]
end

Rack::Handler::Thin.run App, :Port => 9292
</code></pre>
<p>Tę aplikację uruchamiamy po prostu tak:</p>
<pre><code>ruby app.rb
</code></pre>

</div>
</div>

<div class="slide"><h4>Instancja klasy aplikacją Rack</h4>
<div class="slidecontent">

<pre><code>:::ruby
# helloworld.rb
class HelloWorld
  def call(env)
    [200, {"Content-Type" => "text/html"}, ["hello world"]]
  end
end
</code></pre>
<p>Tę klasę/aplikację uruchamiamy tak:</p>
<pre><code>rackup -s thin -p 9292 app2.ru 
</code></pre>
<p>gdzie w pliku <i>app2.ru</i> wpisujemy:</p>
<pre><code>:::ruby
require 'helloworld'
run HelloWorld.new
</code></pre>

</div>
</div>

<div class="slide"><h4>Rack Middleware czyli Filtry</h4>
  <div class="slidecontent">
    <p class="quote">
      Between the server and the framework, Rack can be customized to your
      applications needs using middleware, for example:
    </p>
    <ul>
      <li><b>Rack::CommonLogger</b>, for creating Apache-style logfiles.</li>
      <li><b>Rack::ShowExceptions</b>, for catching unhandled exceptions and
          presenting them in a nice and helpful way with clickable backtrace.</li>
      <li><b>Rack::File</b>, for serving static files.</li>
      <li><b>Rack::Static</b> intercepts requests for static
          files (javascript files, images, stylesheets, etc) based on
          the url prefixes passed in the options, and serves them
          using a Rack::File object.</li>
      <li>...and many others!</li>
    </ul>
  </div>
</div>

<div class="slide"><h4>Aplikacja Rack z middleware</h4>
  <div class="slidecontent">
    <img src="/images/rack-1.png" alt="rack: middleware | apps">
  </div>
</div>


<div class="slide"><h4>Aplikacja middleware, to filtr</h4>
  <div class="slidecontent">

<p>Aplikacje składamy tak, jak składamy funkcje:</p>

<pre><code>:::ruby
app = Rack::CommonLogger.new(                  
        Rack::ShowExceptions.new(              
          Rack::Lint.new(MyRackApp.new)))
</pre></code>

<p>Albo tak:</p>

<pre><code>:::ruby
app = MyRackApp.new
app = Rack::Lint.new(app)
app = Rack::ShowExceptions.new(app)
app = Rack::CommonLogger.new(app)
</pre></code>

</div>
</div>


<div class="slide"><h4>...więcej middleware</h4>
  <div class="slidecontent">
    <ul>
      <li><b>Rack::URLMap</b>, to route to multiple applications inside the same process.</li>
      <li><b>Rack::Cascade</b>, tries an request on several apps, 
          and returns the first response that is not 404 
          (or in a list of configurable status codes).</li>
      <li><b>Rack::Builder</b> implements a small DSL to iteratively 
          construct Rack applications.</li>
    </ul>
  </div>
</div>

<div class="slide"><h4>Iteracyjne składanie + kaskada aplikacji Rack</h4>
  <div class="slidecontent">
    <img src="/images/rack-2.png" alt="rack: middleware | apps">
  </div>
</div>

<div class="slide"><h4>Rack::Builder — składamy middleware z aplikacją</h4>
<div class="slidecontent">

<pre><code>:::ruby
# rapp.ru
require 'helloworld'

Rapp = Rack::Builder.new do
  use Rack::CommonLogger
  use Rack::Lint
  run HelloWorld
end
</code></pre>
<p>Aplikację <i>rapp.rb</i> uruchamiamy tak:</p>
<pre><code>rackup rapp.ru
</code></pre>
<p>Polecenie <code>rackup</code> doda za nas wiersz z <i>Rack::Handler</i>
   oraz bibliotekę <i>rubygems</i> i <i>rack</i>.</p>

</div>
</div>

<div class="slide"><h4>Aplikacje Rack: Pi, Euler...</h4>
  <div class="slidecontent">
<pre><code>:::ruby
require 'rack/request' ; require 'rack/response'
require 'bigdecimal' ; require 'bigdecimal/math'
include BigMath
module Rack
  class Pi
    def call(env)
      req = Request.new(env)
      prec = req.GET["prec"].to_i
      res = Response.new
      res.write "&lt;title>PI&lt;/title>"
      res.write "&lt;p>"
      res.write PI(prec + 1).to_s("10F")
      res.write "&lt;/p>"
      res.finish
    end
  end
end
</code></pre>
  </div>
</div>

<div class="slide"><h4>Iteracyjnie budujemy aplikację</h4>
<div class="slidecontent">

<pre><code>:::ruby
# app3.rb
require 'rack-math' # gem z aplikacjami Rack:Euler, Rack:Pi...
App3 = Rack::Builder.new do
  map '/euler' do
    run Rack::Euler.new
  end
  map '/pi' do
    run Rack::Pi.new
  end
end
</code></pre>

</div>
</div>

<div class="slide"><h4>...kontynuuuuacja poprzedniego slajdu</h4>
<div class="slidecontent">

<p>Włączamy jeszcze jedną aplikację z gemu *rack*: 
<pre><code>:::ruby
# app4.rb
require 'rack/lobster'
require 'app3'
App4 = Rack::Builder.new do
  map '/math' do
    run App3
  end
  map '/lobster' do
    run Rack::Lobster.new
  end
end
</code></pre>

<p>Uruchamiamy aplikację *app4.ru*:
<pre><code>:::ruby
require 'app4'
use Rack::CommonLogger
run App4
</code></pre>

</div>
</div>


<div class="slide"><h4>Modułowe aplikacje Sinatry: Sinatra:Pi, Sinatra:Euler</h4>
<div class="slidecontent">

<p>Korzystamy z <b>layoutu</b> i <b>szablonów</b>. Kopiujemy zmienne do szablonów.</p>

<pre><code>:::ruby
# sinatra-math/pi.rb
require 'bigdecimal'
require 'bigdecimal/math'
include BigMath

module Sinatra
  class Pi < Sinatra::Base
    get '/?' do
      prec = params[:prec].to_i
      @pi = PI(prec + 1).to_s("10F")
      @cname = 'PI'
      erb :pi
    end    
  end
end
</code></pre>

</div>
</div>

<div class="slide"><h4>...kontunuuuuacja poprzedniego slajdu</h4>
<div class="slidecontent">

<p>Dodamy do tej aplikacji homara i uruchomimy ją 
via pomocniczy pliczek dla programu rackup.</p>
<pre><code>:::ruby
# app5.ru
require 'sinatra/base'
require 'sinatra-math'
require 'rack/lobster'

SinatraApp5 = Rack::Builder.new do
  map '/' do 
    run Sinatra::Pi.new
  end
  map '/lobster' do
    run Rack::Lobster.new
  end
end

run SinatraApp5
</code></pre>

</div>
</div>


<div class="slide"><h4>Modułowe aplikacje Rails 3</h4>
<div class="slidecontent">

    <p>
      Yehuda Katz, 
      <a href="http://en.oreilly.com/rails2009/public/schedule/detail/7785">The 
      Russian Doll Pattern: Mountable apps in Rails 3</a>
    </p>
    <blockquote cite="http://en.oreilly.com/rails2009/public/schedule/detail/7785">
      <p>One of the hottest new features in Rails 3 is the ability to
      embed a Rails application in another Rails application. This
      allows the development of components that range from user
      authentication to a fully featured forum. These components can
      then be distributed as gems and fully integrated with another
      application. In fact, user private messaging could be a stand
      alone app, which is then mounted into a forum app, and finally
      mounted into your own custom app.</p>
    </blockquote>

</div>
</div>


<div class="slide"><h4>Prawa Murphy’ego (1918–1990)</h4>
<div class="slidecontent">
    <blockquote>
      <img src="/images/emurphy.gif" alt="E. A. Murphy">
      <p>Nic nie jest tak łatwe, jak wygląda.</p>
    </blockquote>
</div>
</div>

<div class="slide"><h4>Railsconf 2009 Recap</h4>
<div class="slidecontent">
    <blockquote cite="http://blog.zerosum.org/?q=node/66">
      <p>Interestingly, I really didn’t care for many of the (very
      rough) ideas expressed in Yehuda’s mountable Rails apps (Rails
      3) session — in particular I really had no clue why they kept
      comparing Rails (a framework) to Drupal (a CMS). But, that said,
      the talk did do a great job stimulating discussion about
      alternative approaches in „CabooseConf” — apparently just a
      small room with, uh, tables and stuff — between myself, Bryan,
      Josh, Ted and others. For this reason it definitely belongs in
      my favorite sessions list.</p>
    </blockquote>
</div>
</div>

<div class="slide"><h4>...more Railsconf 2009 Recap</h4>
<div class="slidecontent">

    <blockquote>
      <p>Każde rozwiązanie ujawnia nowe problemy.</p>
      <p class="author">— Edward A. Murphy</p>
    </blockquote>

    <blockquote cite="http://blog.zerosum.org/?q=node/66">
      <p>[mountable app slices] are a challenging problem, and there
      are a lot of issues in terms of sharing application state,
      resolving cross-app dependencies, and so on. I hope that we’ll
      have an elegant solution to this soon; but I suspect that the
      real answer may be in making component-sized micro-apps easier
      to mount and integrate rather than taking an „app slices” or
      engines approach (if the latter case prevails, the Radiant
      extensions system has some stuff we can learn from).</p>
    </blockquote>

</div>
</div>

